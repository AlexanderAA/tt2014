\documentclass[12pt,a4paper,oneside]{article}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
%\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{enumerate}
\usepackage{bnf}
%\usepackage[UglyObsolete,tight,heads=LaTeX] {diagrams}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm,bindingoffset=0cm]{geometry}
\usepackage{proof}
\begin{document}

\newcommand{\chr}[1]{\mbox{`\texttt{#1}'}}
\newcommand{\nt}[1]{\mbox{#1}}
\newcommand{\rep}[2]{\{#1\}^#2}

Домашние задания по курсу <<Теория типов>>

\begin{enumerate}
\item На вход вашей программе дается файл task1.in,
содержащий лямбда-выражение в следующей грамматике:
\begin{bnf}\begin{eqnarray*}
<\nt{Абстракция}> & ::= & \chr{\textbackslash} <\nt{Переменная}> \chr{.} <\nt{Абстракция}> | <\nt{Применение}> \\
<\nt{Применение}> & ::= & <\nt{Применение}> <\nt{Терм}> | <\nt{Терм}> \\                         
<\nt{Терм}> & ::= & \chr{(} <\nt{Абстракция}> \chr{)} | <\nt{Переменная}> \\
<\nt{Переменная}> & ::= & (\chr{a}\dots\chr{z}) \rep{\chr{0}\dots\chr{9}}{*} \rep{\chr{\'}}{*}
\end{eqnarray*}\end{bnf}%
Аргументы в применении должны разделяться пробелом, если оба аргумента - переменные.
Любые пробелы между нетерминальными символами (кроме пробела, разделяющего аргументы в применении),
--- а также начальные и конечные пробелы в строке --- должны игнорироваться. Символы табуляции,
возврата каретки и перевода строки должны трактоваться как пробелы.

Требуется расставить все недостающие скобки вокруг всех абстракций и применений,
и напечатать получившийся результат в файле task1.out.

Например:\\\chr{\textbackslash{}a.\textbackslash{}b.a b c (\textbackslash{}d.e \textbackslash{}f.g) h}\\
должно превратиться в\\
\chr{\textbackslash{}a.(\textbackslash{}b.((((a b) c) (\textbackslash{}d.(e (\textbackslash{}f.g)))) h)))}

\item В файле task2.in задано некоторое лямбда-выражение, требуется найти список свободных
переменных в нем и напечатать в алфавитном порядке, по идентификатору на строке.

\item В файле task3.in задана подстановка в некоторое лямбда-выражение в следующем синтаксисе 
(расширение определения из первой задачи):
\begin{bnf}\begin{eqnarray*}
<\nt{Условие}> & ::= & <\nt{Абстракция}> \chr{[} <\nt{Переменная}> \chr {:=} <\nt{Абстракция}>
\end{eqnarray*}\end{bnf}%

Требуется в выходном файле task3.out привести результат подстановки, либо указать фразу
\chr{Нет свободы для подстановки для переменной } <\nt{Переменная}>.

\item В файле task4.in дано лямбда-выражение, требуется преобразовать его в нормальную форму 
и результат записать в файл task4.out. Если выражение не имеет нормальной формы, результат 
работы программы может быть произвольным.

\item Преобразовать лямбда-выражение в комбинаторное выражение в базисе $SKI$. 

На вход в файле task5.in задано лямбда-выражение, выведите в файл task5.out бета-эквивалентное 
ему выражение в базисе $SKI$. Результирующее выражение должно соответствовать грамматике для
лямбда-выражений, но не должно содержать лямбда-абстракций. В качестве значений можно использовать
только большие буквы \chr{S}, \chr{K} и \chr{I} и свободные переменные из исходного выражения.

\item Унификация термов. На вход в файле task6.in задан список уравнений в алгебраических термах, 
по уравнению на строке. Каждое уравнение соответствует следующей грамматике:

\begin{bnf}\begin{eqnarray*}
<\nt{Уравнение}> & ::= & <\nt{Терм}> \chr{=} <\nt{Терм}>\\
<\nt{Терм}> & ::= & <\nt{Функция}> \chr{(} <\nt{Терм}> (\chr{,} \nt{Терм})\!\!^* \chr{)} | <\nt{Переменная}> \\
<\nt{Функция}> & ::= & (\chr{a}\dots\chr{h}) \rep{\chr{0}\dots\chr{9}}{*} \rep{\chr{\'}}{*} \\
<\nt{Переменная}> & ::= & (\chr{i}\dots\chr{z}) rep{\chr{0}\dots\chr{9}}{*} \rep{\chr{\'}}{*}
\end{eqnarray*}\end{bnf}%

Решите эту систему уравнений и выведите в файл task6.out наиболее общую подстановку, по строке
на каждую переменную, используя следующую грамматику:

\begin{bnf}\begin{eqnarray*}
<\nt{Строка подстановки}> & ::= & <\nt{Переменная}> \chr{=} <\nt{Терм}>\\
\end{eqnarray*}\end{bnf}%

\item Просто типизированное лямбда-исчисление. На вход в файле task7.in задано лямбда-выражение.
Выведите в файл task7.out какой-нибудь наиболее общий тип для этого выражения в просто типизированном 
лямбда-исчислении (если этот тип существует), или укажите, что выражение типа не имеет.

Результат должен соответствовать следующей грамматике:

\begin{bnf}\begin{eqnarray*}
<\nt{Ответ}> & ::= & <\nt{Тип}> | \chr{Лямбда-выражение не имеет типа.} \\
<\nt{Тип}> & ::= & <\nt{Перем}> | <\nt{Перем}> \chr{->} <\nt{Тип}> | \chr{(} <\nt{Тип}> \chr{)}\\
<\nt{Перем}> & ::= & (\chr{a}\dots\chr{z}) \rep{\chr{0}\dots\chr{9}}{*} \rep{\chr{\'}}{*}
\end{eqnarray*}\end{bnf}%

\item Расширенное лямбда-исчисление. 
На вход программы в файле task12.in задается выражение в лямбда-исчислении
с конструкцией let. Выражение соответствует следующей грамматике:

\begin{bnf}\begin{eqnarray*}
<\nt{Выражение}> & ::= & \chr{let} <\nt{Переменная}> \chr{=} <\nt{Выражение}> \chr{in} <\nt{Выражение}>\\
<\nt{Абстракция}> & ::= & \chr{.} <\nt{Переменная}> \chr{.} <\nt{Абстракция}> | <\nt{Применение}> \\
<\nt{Применение}> & ::= & <\nt{Применение}> <\nt{Терм}> | <\nt{Терм}> \\                         
<\nt{Терм}> & ::= & \chr{(} <\nt{Абстракция}> \chr{)} | <\nt{Значение}> \\
<\nt{Значение}> & ::= & (\chr{a}\dots\chr{z}) \rep{\chr{0}\dots\chr{9}}{*} \rep{\chr{'{}}}{*}\\
                & | & \chr{F}|\chr{T}|\chr{If}|\chr{Y}|\chr{Plus}|(\chr{0}\dots\chr{9})\!\!^+\\
                & | & \chr{<}<\nt{Значение}>\chr{,}<\nt{Значение}>\chr{>} | \chr{PrL} | \chr{PrR}\\
                & | & \chr{InL} | \chr{InR} | \chr{Case}
\end{eqnarray*}\end{bnf}%
Аналогично простым лямбда-выражениям, 
если подряд указаны какие-либо идентификаторы или ключевые слова let и in, 
то они будут разделяться пробелом.
Любые другие пробелы --- а также начальные и конечные пробелы в строке --- должны игнорироваться. Символы табуляции,
возврата каретки и перевода строки должны трактоваться как пробелы.

Требуется нормализовать выражение. Для переменных особого вида следует применять следующие
правила редукции:

\begin{tabular}{ll}
Исходное выражение & Бета-редукция выражения\\
\hline
\chr{If T t e} & \chr{t}\\
\chr{If F t e} & \chr{e}\\
\chr{Plus x y} & $(x+y)\%2^{63}$, если x,y --- числа, иначе --- ошибка\\
\chr{Y f} & \chr{f (Y f)}\\
\chr{PrL <a,b>} & \chr{a}\\
\chr{PrL <a,b>} & \chr{b}\\
\chr{Case (PrL x) l r} & \chr{l x}\\
\chr{Case (PrR y) l r} & \chr{r y}
\end{tabular}%

Частичное применение переменных особого вида допускается (в этом случае имеет
место классический карринг). 
Если какое-то применение переменной особого вида отсутствует в списке 
(например, \chr{If 0 1 2}) --- то его редукция должна приводить к ошибке.

В качестве примеров к программе должны быть приложены выражения для вычисления:
\begin{itemize}
\item по числу $n$ ($0 \le n \le 91$) вычислить $n$-е число Фибоначчи $F_n$ 
(подсказка: $F_91 = 7540113804746346429$)
\item по числу $n$ вернуть упорядоченную пару $<a,b>$, где $a$ --- число цифр
в двоичном разложении $n$ (без ведущих нулей), а $b$ --- сумма цифр в двоичном
разложении.
\end{itemize}

\item Алгоритм $W$.

На вход программе передается файл task13.in, содержащий расширенное лямбда-выражение.
Требуется применить алгоритм $W$ и выдать в выходной файл результирующий тип и контекст
в следующей грамматике:

\begin{bnf}\begin{eqnarray*}
<\nt{Ответ}> & ::= & <\nt{Тип}> \chr{\textbackslash{}n} <\nt{Контекст}> | \chr{Лямбда-выражение не имеет типа.} \\
<\nt{Контекст}> & ::= & \rep{<\nt{Переменная}> \chr{=} <\nt{Тип}> \chr{\textbackslash{}n}}{*} \\
<\nt{Тип}> & ::= & <\nt{Тип}> | <\nt{Дизъюнкция}> \chr{->} <\nt{Тип}> | \chr{(} <\nt{Тип}> \chr{)}\\
<\nt{Дизъюнкция}> & ::= & <\nt{Дизъюнкция}> \chr{|} <\nt{Конъюнкция}> | <\nt{Конъюнкция}>\\
<\nt{Конъюнкция}> & ::= & <\nt{Конъюнкция}> \chr{\&} <\nt{Имя-типа}> | <\nt{Имя-типа}>\\
<\nt{Переменная}> & ::= & (\chr{a}\dots\chr{z}) \rep{\chr{0}\dots\chr{9}}{*} \rep{\chr{'}}{*}\\
<\nt{Имя-типа}> & ::= & <\nt{Переменная}> | \chr{Bool} | \chr{Int} 
\end{eqnarray*}\end{bnf}%

У выражений особого вида должны быть следующие особые типы:

\begin{tabular}{ll}
Имя & Тип\\
\hline
T,F & $Bool$\\
If & $Bool \rightarrow a \rightarrow a \rightarrow a $\\
$0,1,\dots,2^{63}-1$ & $Int$\\
Inc & $Int \rightarrow Int$\\
$< x^a, y^b >$ & $a \& b$\\
PrL & $a\&b \rightarrow a$\\
PrR & $a\&b \rightarrow b$\\
InL & $a \rightarrow a | b$\\
InR & $a \rightarrow a | b$\\
Case & $a | b \rightarrow (a\rightarrow c) \rightarrow (b\rightarrow c) \rightarrow c$\\
Y & $(a \rightarrow a) \rightarrow a$
\end{tabular}%

Убедитесь, что решения для примеров из предыдущей задачи правильно типизируются.

\end{enumerate}

\end{document}
