\section{Основные задачи}

Можно задаться вопросом: что мы можем получить с этой теории?
Традиционно рассматривают следующие три задачи:

\begin{enumerate}
\item Задача проверки типов --- проверить, выполнено ли $\Gamma \vdash M:\sigma$ для
данных $\Gamma$, $M$ и $\sigma$.
\item Задача восстановления (синтеза) типов (типизируемости) --- проверить, возможно ли для
данного лямбда-выражения $M$ найти такие $\Gamma$ и $\sigma$, что $\Gamma \vdash M:\sigma$.
\item Задача населенности типа --- проверить, найдется ли для данного типа $\sigma$ терм $M$, такой, что
что $\vdash M:\sigma$.
\end{enumerate}

Для просто типизируемого лямбда-исчисления существует алгоритмическое решение для всех
трех задач. Сейчас мы познакомимся с ним.

\section{Синтез типа и обитаемость типа}

Прежде чем перейти к более сложным типовым системам, нам осталось ответить на важный
вопрос о наличии эффективных процедур, позволяющих определить, существует ли лямбда-выражение,
имеющее некоторый тип в некотором контексте: $\Gamma\vdash ?:\sigma$

\begin{definition}
Мы будем называть некоторый тип $\sigma$ в контексте $\Gamma$ \emph{обитаемым}, если 
найдется такое выражение $M$, что $\Gamma\vdash M:\sigma$.
\end{definition}

\begin{theorem}
Задача определения обитаемости типа --- разрешима.
\end{theorem}

\begin{proof}
Для доказательства предоставим разрешающий алгоритм.
\end{proof}

\section{Упорядоченные пары и алгебраические типы данных}

Сперва попробуем расширить понятие типа экстенсивно: через добавление новых связок, не изменяя
порядка исчисления. Естественные кандидаты здесь --- конъюнкция и дизъюнкция, для которых 
изоморфизм Карри-Ховарда предлагает следующие аналоги:

\begin{tabular}{lll}
Конструкция&Связка&Операции\\
\hline
Упорядоченная пара & $\alpha\&\beta$ & $\pi_1: \alpha\&\beta\rightarrow\alpha$\\
	& & $\pi_2: \alpha\&\beta\rightarrow\beta$\\
	& & $\langle\alpha,\beta\rangle: \alpha\rightarrow\beta\rightarrow\alpha\&\beta$\\
Алгебраический тип & $\alpha\vee\beta$ & $in_1: \alpha\rightarrow\alpha\vee\beta$\\
	& & $in_2: \beta\rightarrow\alpha\vee\beta$\\
	& & $case: (\alpha\rightarrow\gamma)\rightarrow(\beta\rightarrow\gamma)\rightarrow\alpha\vee\beta\rightarrow\gamma$
\end{tabular}

\section{Исчисление 1-го порядка}

Более радикальный путь усиления теории --- рассмотрение исчислений 1-го и высших порядков.
Подробно на теориях 1-го порядка мы останавливаться не будем, единственное, отметим, что
такая теория будет требовать определение выражений двух сортов: предметных и логических.
Аналогом с точки зрения изоморфизма Карри-Ховарда для логических значений будут типы,
а предметными выражениями могут быть любые выражения над не-типовыми значениями: например,
над строками, целыми числами и т.п. 

Аналог предиката в данном случае --- это функция, отображающая значение предметного множества 
в тип. Такой тип, зависящий от предметной переменной, называется \emph{зависимым}. 

Самый, видимо, известный пример подобного --- шаблоны в C++. Если мы будем рассматривать
значения, представимые в откомпилированном коде, в качестве элементов предметного множества,
типы --- как значения пропозициональных переменных, а шаблоны, параметризованные элементарными 
значениями --- как предикаты, то мы как раз получим исчисление с зависимыми типами.

Например, шаблону
\begin{verbatim}
template <int a>
struct X { int v[a]; };
\end{verbatim}
мы могли бы сопоставить тип: $X:\forall a.$

Хотя, конечно, система типов в C++ значительно сложнее и в приведенное исчисление 1-го порядка
не помещается в точности: например, мы проигнорировали в формализации, что аргументы шаблонов 
имеют тип (и получается, что кванторы ограничены некоторым подмножеством предметного множества).

\section{Исчисление 2-го порядка}

Те же шаблоны из C++ позволяют задавать и более сильные операции: отображения из типов в типы.
Такие типы (зависящие от других типов) в логике имеют аналогом предикаты, зависящие от других
логических значений. Это уже --- исчисление предикатов 2-го порядка.
Изучение такого исчисления и соответствующей ему системы типов и будет нашей ближайшей целью.

\subsection{Импликационный фрагмент интуиционистского исчисления второго порядка}

\subsection{Система F}

\begin{definition}
\end{definition}

%L = \Lambda \sigma . \L | \lambda x . \L |  
